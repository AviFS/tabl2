class Frink extends Lang {

    static name = "Frink";
    
    static tablook = [{"level":1,"header":"Interval Arithmetic","link":"#frink##ZUy7DsIwENvvKzyXa4ALbejQL0GHlIgMSG2HCkH@PpwYgwfL8qvWiBlb/uC5vfL@jstN2Cul1h04KEV08MYHpJ9O9PhfQ9zAsI/cZoFxdVaY3EVt2SFTaTu9sCiVu9DaRp5HpbM7HVcy1PoF"},{"level":1,"header":"Interval Arithmetic Example","link":"#frink##bY5NCsIwEIX3OcWQlSISsK6EuvMG7koLIZ3agSYNSVrw9DFpqag4q/n53psXoyKnJt2hQ6MQSsBZDhUZO4WK30xAB9/E2IEEb/s0XoDXNdPS@7@60CMsxyTJ/aeoJakxQ@WPvQBLzMmWpmz6xgSc2DwOk84Rz6JIFKxUU7AWjafwTJflnYCVZNaRCYOp@D193yDyKQEcYLctjlfgD6F0U/B9zVLF@AI"},{"level":1,"header":"Sample Calculations","link":"#frink##@/8/N7G4WCExL0WhLD@nNDeVy9BAIS01tUTB0AhCW0AoXTuF9MScnPy8Yi4jhRIgpaCvoIGutjyxJLVIE6QWxOXi4vr/HwA"},{"level":1,"header":"Liquor","link":"#frink##XY5BCsIwFAX3OcUjK12YmpYgLupdYviNLb9JCQ2Cl48NSKHuZ@a9Ut52pdRYdvEVWTyJEnroFgPHDzrVYqHkKKw4grP1Ic/QnTI7cXmg@mLKwTNNeXRUW@pmwOMmQ9@vWFKMAxqcDLxljuF84LeG/PWkMPuRf6TuSCFEKV8"},{"level":1,"header":"More Liquor","link":"#frink##bcxBCsIwFATQfU4xdNUubJIWtd14lxh/Vfz2lzRQ8PLRQAWF7gZm3qT0oCt2J3g3k1qzbTCwvFR5MLgIswtzpctctnWDiYKnMWJxkYJ27OUmXGVXrGOddfHhdd//HCz3kc4SIxNs@73ZhLb9l/a4N3gyOoMpiAxbSKmU3g"},{"level":1,"header":"Movie Magic","link":"#frink##@//fUN9EITc/Py83sbhYQV9Bw0TfWKEgU0HD1MBA30ghO1czzlhTQddOoTyxJLWIy10BXT1CnRFIWXpRYllmSSUXF9f//wA"},{"level":1,"header":"Fiscal Calculations","link":"#frink##@/8/qbQoryixJFXBVkFD2cjAwFDXwEzX2EBZQVcBxDXQNTTSNTZU1lTQV9DQsDAzsTAEypgYmhkYaiqUZOSXFifmpSik5OfkJBYVa3LBTdO1gwnqpyRWcoE1YKgHmomsQQmosliJC8UV2goEtXJxcf3/DwA"},{"level":1,"header":"Ouch!","link":"#frink##@//f1FAhvSgxt1ghxC9EQddOwdDCVKEgvzQvpRgkXpZZUqmQlppawoWuTqkkNbG4ID8/D6gusTg/JzMvVYmLi@v/fwA"},{"level":1,"header":"Microwave Cookery","link":"#frink##@//f0NDAQCFcwdhAoTg1WUFfQcPIXCG/SsFQITkxJ78oM1U/vSgxVz8lNd1ZU0HXTgHIcOPi4vr/HwA"},{"level":1,"header":"Why is Superman so Lazy?","link":"#frink##fY0xDsIwFEP3fwqPrRAiCURMcBSkqPy2GUii5JeK04cglrKwWfazXSu7LHOKK2dcUJbwlQd0JyT/Me6@yM30NMwuT5ydcAM3LW0wNmCb769YnUghA4kBZ4zMgim7p5dX2/5FCw/UGWOxgz7aHim20wJtlVL/mw8fFuFCRLW@AQ"},{"level":1,"header":"Fart Jokes","link":"#frink##lc2xCsIwGATgPU9xY4No04CCi0t3p85KwGCCaf6QPyJ9@li7CXVwPe67q7XTuz0ePlChyBjOA1o0B0zWZMYGR4wUi2OJ7QmOMttEL5vFP6w3gbK33N7MtA61UuqrtrhlbBVEU57ZhOvd8K/fOU4ezWx9lBct0anP5picEKLWNw"},{"level":1,"header":"Advanced Farting","link":"#frink##jY69CsIwFIX3PMUZq2KaRgrpoIubg1NfIOjFluanJFHo08e4iEvB6d7Lx/nuyXmQ5Cg8FhwhhRCwBjWsNzq8vHla@uzYoukwU7iRS@WQquUK06UujFlKg3b0l@XA5Y9GdWJNs8O31/6EszY@jBRZI3mLaTQ@eRfRX/vyparWoptC77qMolhIh8gYy/kN"},{"level":1,"header":"Days Old","link":"#frink##@/9f2dDSzFLXwELX0FJZQVvB0MjY0EQhJbGymAtNJrFUQV9Bw9JMz9xEITczJyczsSi5ODVZEyiazAWR1DM3NzJWgInr2inkZKZnlFSmJhYVc3Fx/f8PAA"},{"level":1,"header":"Model Solar System","link":"#frink##TY1BCoNADEX3niJLh6Jii5Qu2ouULsJMqoEaYTKef2rqIF0m7/3/c1aPH4I7EMY0RQy8KnRQX9oBWPxE6qp5WeQgu988Cv3BwJr@0ZsoVX17K4719det0P7OBIx@ZlnTlj/boSzPfaGry9IJrBXFk3tZJNAYiTTnLw"}];
    static commandPrefix = '!';

    static mod = false;

    static getAddress(localhost) {
        // return 'ws://127.0.0.1:8884';
        if (localhost) {
            return 'ws://127.0.0.1:8002';
        }
        return 'ws://54.153.39.161:8884/';

    }

    static init() {
        [
            // "showApproximations[false]",

            // these three were my defaults before parsing frink's output on frontend
            // "rationalAsFloat[true]",
            // "setPrecision[10]",
            // "showDimensionName[false]",

        ].forEach(code => send(ws, {"code": code}));
        // More efficient if .join(";") and send it in one JSON
    }
    

    // static postProcess(disp) {
    //     let out = parseFrinkOutput(disp);

    //     if (!out.matched == true) {
    //         return out.original;
    //     }

    //     // let decimal = out.decimal;
    //     let decimal = Utils.round(out.decimal, 6);
    //     let units = out.units.slice(0,3);
    //     // units = units.map(x => String(x).padStart(3, " "))
    //     units = "(" + units.join(", ") + ")"

    //     return `${decimal} ${units}`;

    // }

    static postProcess(disp) {
        if (disp[0] == '[') {
            let items = disp.slice(1, disp.length-1).split(', ')
            return items.join('\n')
        }

        if (Frink.mod == true) {
            Frink.mod = false;
            let out = parseFrinkOutput(disp);
            let dimension = out.dimension=="unknown unit type"? '*': out.dimension;
            return dimension;
        }
        return pprintFrinkOutput(disp);
    }

    static updateDisp(line) {
        let item = disp[line];
        if (item.type == "Empty") {
            updateLine(line, "");
        }

        else if (item.type == "Static") {
            // if current line, show full thing
            if (getLineNumber() == line) {
                updateLine(line, Frink.postProcess(item.text));
                return;
            }

            // if not current line, show one-line version
            updateLine(line, Frink.postProcess(item.text).split('\n').join(', '));
        }
    }

    static runCommand(command) {
        if (command[1] == '!') {
            return recursiveGetUnit(command.slice(2)).join('\n');
        }
        return getUnit(command.slice(1));
    }

    // not very smart but better than the alternative
    static whichLines(lines) {
        function range (a,b) { return Array.from({length:b-a},(_,i)=>i+a); }
        function runAll(code) { return code.includes("=!"); }
        function hasAssignment(code) { return code.includes("="); }
        // That second check is just for Ad√°m. Did I get that right?
    
        let children = document.getElementById('right').children;
    
        let accLines = [];
        for (let i=0; i<lines.length; i++) {
            let line = lines[i];
            let code = getLine(line);
            if (runAll(code)) {
                // return lines;
                return range(0, children.length);
            }
            if (hasAssignment(code)) {
                let before = range(0, line).filter(function(i) {
                    return hasAssignment(getLine(i));
                });

                // Both are equivalent. I have to figure out which is easier to read/understand
                // accLines means I can do `for (const line of lines)` whereas slice means I can get rid of the accumulator/pushing
                let otherLines;
                otherLines = lines.slice(0, i);
                otherLines = accLines;

                let after = range(line, children.length);
                return [].concat(before, otherLines, after);
            }
            accLines.push(line);
        }
        return lines;
    }


    static input(code=true) {
        let prev = lines;
        linesUpdate()
        let changedLines = diffLines(prev, lines)
    
        if (debug == 0.5 || debug == 1.5) {
            console.log("changedLines:\n", changedLines);
        }
    
        let children = document.getElementById('right').children;
    
        let input = document.getElementById('input').innerText;
    
        // this shouldn't be necessary, for most langs, but just to save a nasty bug down the line
        // without this, if you enter input, but you have no code, nothing runs
        // that's just what we want... except for langs where input alone can create output
        if (code == false && document.getElementById('left').value.trim() == "") {
            send(ws, {line: 0, code: code, input: input});
            return;
        }
    
        // send(ws, {reset: true})
    
        let lineNums = lang.whichLines(changedLines);
        // let lineNums = changedLines;
        if (debug > 0) {
            // console.log(`runningLines\n`, lineNums)
            let running = lineNums.filter(x => !lang.isIgnore(getLine(x)));
            console.log(`running lines:\n`, running);
        }
    
        for (const i of lineNums) {
            let code = getLine(i);
            if (lang.isIgnore(code)) {
                disp[i] = {type: "Empty"}
                lang.updateDisp(i);
                continue;
            }
            // if (code[0] == lang.commandPrefix) {
            //     let res = lang.runCommand(code);
            //     disp[i] = {type: "Static", text: res? res: disp[i]};
            //     continue;
            // }
            let data = { line: i, code: code, input: input, reset: false, state: [] };

            if (code[0] == '!') {
                if (code[1] == '!') {
                    disp[i] = {type: "Static", text: recursiveGetUnit(code.slice(2)).join('\n')};
                    lang.updateDisp(i);
                }
                else if (code[1] == '(') {
                    function parseTuple(tuple) {
                        let s = tuple.split(',');
                        for (let i=0; i<3; i++) {
                            if (i > s.length-1) s.push(0)
                            else s[i] = parseInt(s[i])
                        }
                        return s
                    }
                    let [m, kg, s] = parseTuple(code.slice(2))
                    let unitString = `m^${m} kg^${kg} s^${s}`;
                    if (code.trim()[code.trim().length-1] == ")") {
                        data.code = `units[${unitString}]`
                        send(ws, data)
                    }
                    else {
                        Frink.mod = true;
                        data.code = unitString;
                        send(ws, data)
                    }
                }
                else {
                    disp[i] = {type: "Static", text: getUnit(code.slice(1))};
                    lang.updateDisp(i);
                }
                continue;
            }

            let trimmed = code.trim()
            if (trimmed.slice(-2) == "??") {
                // Frink.mod = true;
                data.code = "units[" + trimmed.slice(0,-2) + "]";
            }
            else if (trimmed[trimmed.length-1] == "?") {
                Frink.mod = true;
                data.code = trimmed.slice(0,-1);
            }
            // can have something a bit more flexible here like this, or even more flexible, but i'll keep the simple prefix command for now:
            /* if (lang.isIntercept(data)) { continue; } */
            send(ws, data)
        }
    }

}